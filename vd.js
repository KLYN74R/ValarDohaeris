/*



                                                                                                                                                                                                                               
                                                                                                                                                                                                                               
VVVVVVVV           VVVVVVVV               lllllll                                    DDDDDDDDDDDDD                        hhhhhhh                                                                       iiii                   
V::::::V           V::::::V               l:::::l                                    D::::::::::::DDD                     h:::::h                                                                      i::::i                  
V::::::V           V::::::V               l:::::l                                    D:::::::::::::::DD                   h:::::h                                                                       iiii                   
V::::::V           V::::::V               l:::::l                                    DDD:::::DDDDD:::::D                  h:::::h                                                                                              
 V:::::V           V:::::Vaaaaaaaaaaaaa    l::::l   aaaaaaaaaaaaa  rrrrr   rrrrrrrrr   D:::::D    D:::::D    ooooooooooo   h::::h hhhhh         aaaaaaaaaaaaa      eeeeeeeeeeee    rrrrr   rrrrrrrrr  iiiiiii     ssssssssss   
  V:::::V         V:::::V a::::::::::::a   l::::l   a::::::::::::a r::::rrr:::::::::r  D:::::D     D:::::D oo:::::::::::oo h::::hh:::::hhh      a::::::::::::a   ee::::::::::::ee  r::::rrr:::::::::r i:::::i   ss::::::::::s  
   V:::::V       V:::::V  aaaaaaaaa:::::a  l::::l   aaaaaaaaa:::::ar:::::::::::::::::r D:::::D     D:::::Do:::::::::::::::oh::::::::::::::hh    aaaaaaaaa:::::a e::::::eeeee:::::eer:::::::::::::::::r i::::i ss:::::::::::::s 
    V:::::V     V:::::V            a::::a  l::::l            a::::arr::::::rrrrr::::::rD:::::D     D:::::Do:::::ooooo:::::oh:::::::hhh::::::h            a::::ae::::::e     e:::::err::::::rrrrr::::::ri::::i s::::::ssss:::::s
     V:::::V   V:::::V      aaaaaaa:::::a  l::::l     aaaaaaa:::::a r:::::r     r:::::rD:::::D     D:::::Do::::o     o::::oh::::::h   h::::::h    aaaaaaa:::::ae:::::::eeeee::::::e r:::::r     r:::::ri::::i  s:::::s  ssssss 
      V:::::V V:::::V     aa::::::::::::a  l::::l   aa::::::::::::a r:::::r     rrrrrrrD:::::D     D:::::Do::::o     o::::oh:::::h     h:::::h  aa::::::::::::ae:::::::::::::::::e  r:::::r     rrrrrrri::::i    s::::::s      
       V:::::V:::::V     a::::aaaa::::::a  l::::l  a::::aaaa::::::a r:::::r            D:::::D     D:::::Do::::o     o::::oh:::::h     h:::::h a::::aaaa::::::ae::::::eeeeeeeeeee   r:::::r            i::::i       s::::::s   
        V:::::::::V     a::::a    a:::::a  l::::l a::::a    a:::::a r:::::r            D:::::D    D:::::D o::::o     o::::oh:::::h     h:::::ha::::a    a:::::ae:::::::e            r:::::r            i::::i ssssss   s:::::s 
         V:::::::V      a::::a    a:::::a l::::::la::::a    a:::::a r:::::r          DDD:::::DDDDD:::::D  o:::::ooooo:::::oh:::::h     h:::::ha::::a    a:::::ae::::::::e           r:::::r           i::::::is:::::ssss::::::s
          V:::::V       a:::::aaaa::::::a l::::::la:::::aaaa::::::a r:::::r          D:::::::::::::::DD   o:::::::::::::::oh:::::h     h:::::ha:::::aaaa::::::a e::::::::eeeeeeee   r:::::r           i::::::is::::::::::::::s 
           V:::V         a::::::::::aa:::al::::::l a::::::::::aa:::ar:::::r          D::::::::::::DDD      oo:::::::::::oo h:::::h     h:::::h a::::::::::aa:::a ee:::::::::::::e   r:::::r           i::::::i s:::::::::::ss  
            VVV           aaaaaaaaaa  aaaallllllll  aaaaaaaaaa  aaaarrrrrrr          DDDDDDDDDDDDD           ooooooooooo   hhhhhhh     hhhhhhh  aaaaaaaaaa  aaaa   eeeeeeeeeeeeee   rrrrrrr           iiiiiiii  sssssssssss    
                                                                                                                                                                                                                               
                                                                                                                                                                                                                               
                                                                                                                                                                                                                               
                                                                                                                                                                                                                               
                                                                                                                                                                                                                               
                                                                                                                                                                                                                               
                                                                    
                                                                                                                                                         
88                           88      a8P   88                                                       888888888888                                         
88                           88    ,88'    88                             ,d                             88                                              
88                           88  ,88"      88                             88                             88                                              
88,dPPYba,   8b       d8     88,d88'       88  8b       d8  8b,dPPYba,  MM88MMM  ,adPPYYba,  8b,dPPYba,  88   ,adPPYba,  ,adPPYYba,  88,dPYba,,adPYba,   
88P'    "8a  `8b     d8'     8888"88,      88  `8b     d8'  88P'   `"8a   88     ""     `Y8  88P'   "Y8  88  a8P_____88  ""     `Y8  88P'   "88"    "8a  
88       d8   `8b   d8'      88P   Y8b     88   `8b   d8'   88       88   88     ,adPPPPP88  88          88  8PP"""""""  ,adPPPPP88  88      88      88  
88b,   ,a8"    `8b,d8'       88     "88,   88    `8b,d8'    88       88   88,    88,    ,88  88          88  "8b,   ,aa  88,    ,88  88      88      88  
8Y"Ybbd8"'       Y88'        88       Y8b  88      Y88'     88       88   "Y888  `"8bbdP"Y8  88          88   `"Ybbd8"'  `"8bbdP"Y8  88      88      88  
                 d8'                               d8'                                                                                                   
                d8'                               d8'                                                                                                    



CREATOR: VLad Chernenko
GitHub:https://github.com/VladChernenko
Organization:https://github.com/VladChernenko



@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@                                                      @
@     Created for ValarDohaeris release for Klyntar    @
@                                                      @
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@



____________________________________________________________Description____________________________________________________________

Useful module to work with different cryptocurrecies

Prepared following GSVDT scheme

G-Generate
S-Sign
V-Verify
D-Derive(keypair from private,seed,etc.)
T-Transfer(transfer everything you need to verify signature)


*/




import{encodeAddress,mnemonicGenerate,mnemonicToMiniSecret} from '@polkadot/util-crypto'

import {crypto as BnbCrypto} from '@binance-chain/javascript-sdk'

import {FilecoinSigner} from '@blitslabs/filecoin-js-signer'

import {Keypair as StellarKeypair} from 'stellar-sdk'

import EosJS from 'eosjs/dist/PublicKey.js'

import {Account} from '@harmony-js/account'

import RippleKeys from 'ripple-keypairs'

import MinaSDK from '@o1labs/client-sdk'

import Tendermint from '@tendermint/sig'

import Harmony from '@harmony-js/crypto'

import SolanaWeb3 from '@solana/web3.js'

import Zil from '@zilliqa-js/crypto'

import Helium from '@helium/crypto'

import secp256k1 from 'secp256k1'

import Arweave from 'arweave'

import AlgoSDK from 'algosdk'

import Base58 from 'base-58'

import nacl from 'tweetnacl'

import crypto from 'crypto'

import ecc from 'eosjs-ecc'

import Web3 from 'web3'








let {Keypair:HeliumKeypair,Address} = Helium,

    filecoin_signer = new FilecoinSigner(),
    
    web3=new Web3(),

    arweave = Arweave.init({}),

    {createWalletFromMnemonic} = Tendermint




export default {




    //KLYNTAR native format
    //RFC8410 Ed25519 keypair
    KLYNTAR:{


        generate:()=>new Promise((resolve,reject)=>{

            crypto.generateKeyPair('ed25519',{
                
                publicKeyEncoding: {type:'spki',format:'der'},
                privateKeyEncoding: {type:'pkcs8',format:'der'}
             
            },(err,publicKey,privateKey)=>
            
                err
                ?
                reject(false)
                :
                resolve(
                  {
          
                    publicKey:Base58.encode(publicKey).slice(16),//if hex(Common-302a300506032b6570032100) slice(16) if base64(Common-MCowBQYDK2VwAyEA)  GfHq2tTVk9z4eXgy-for BASE58
          
                    privateKey:privateKey.toString('base64')//if hex(Common-302e020100300506032b657004220420) slice(21) if base64(Common-MC4CAQAwBQYDK2VwBCIEI)
                  
                  }
                
                )
            
              )
          
          }).catch(e=>false),



        sign:(data,privateKey)=>new Promise((resolve,reject)=>

            crypto.sign(null,Buffer.from(data),'-----BEGIN PRIVATE KEY-----\n'+privateKey+'\n-----END PRIVATE KEY-----',(e,sig)=>
     
                e?reject(''):resolve(sig.toString('base64'))
    
            )
    
        ).catch(e=>''),

       

        verify:(data,signature,pubKey)=>new Promise((resolve,reject)=>

            //Add mandatory prefix and postfix to pubkey
            crypto.verify(null,data,'-----BEGIN PUBLIC KEY-----\n'+Buffer.from(Base58.decode('GfHq2tTVk9z4eXgy'+pubKey)).toString('base64')+'\n-----END PUBLIC KEY-----',Buffer.from(signature,'base64'),(err,res)=>
    
                err?reject(false):resolve(res)
    
            )
    
        ).catch(e=>false)
    

    },

    


    // XPR GSVDT scheme
    XRP:{

        generate:seedOptions=>{
            
            let seed=RippleKeys.generateSeed(seedOptions),
                
                keyPair=RippleKeys.deriveKeypair(seed)

            return {seed,keyPair,address:RippleKeys.deriveAddress(keyPair.publicKey)}

        },

        sign:(stringData,privateKey)=>RippleKeys.sign(stringData,privateKey),

        verify:(plainText,signature,publicKey)=>RippleKeys.verify(plainText,signature,publicKey)

    },




    //For EVM chains which supports such format
    //!Change output data(minimization)
    ETH_LIKE:{

        generate:()=>{
            
            let {address,privateKey}=web3.eth.accounts.create()
            
            return {address,privateKey}
        
        },

        sign:(data,privateKey)=>web3.eth.accounts.sign(data,privateKey),

        verify:(signature,address)=>web3.eth.accounts.recover(signature)===address

    },




    ALGORAND:{

        generate:()=>{
            
            let acc=AlgoSDK.generateAccount()

            return {acc,mnemonic:AlgoSDK.secretKeyToMnemonic(acc.sk)}
        
        },
        
        sign:(data,privateKey)=>Buffer.from(AlgoSDK.signBytes(Buffer.from(data),privateKey)).toString('base64'),
        
        verify:(data,signature,address)=>AlgoSDK.verifyBytes(Buffer.from(data),Buffer.from(signature,'base64'),address),
        
        deriveAccFromMnemonic:phrase=>AlgoSDK.mnemonicToSecretKey(phrase)

    },



    
    FILECOIN:{

        generate:async(mnemonicBitsStrength,network,derivationPath=`m/44'/461'/0'/0/0`)=>{

            let mnemonic = await filecoin_signer.wallet.generateMnemonic(mnemonicBitsStrength),

                keyPair = await filecoin_signer.wallet.keyDerive(mnemonic,derivationPath,network)


            return {mnemonic,keyPair}

        },

        
        /**
        *   To sign random string data
        *
        *   @param {string} data String data to sign
        *   @param {string} privateKey  32-bytes hexadecimal privateKey
        * 
        *   @returns {Promise<String>}
        */
        sign:(data,privateKey)=>filecoin_signer.utils.signMessage(data, privateKey),


        /**
        *   To verify random string data
        *
        *   @param {string} data String data to sign
        *   @param {string} signature  64-bytes hexadeciml signature
        *   @param {string} address Address of signer
        *   @returns {Promise<boolean>} Is valid signature?
        */
        verify:(data,signature,address)=>filecoin_signer.utils.verifySignature(data,signature,address)

    },




    BINANCE_CHAIN:{


        generateMnemonic:()=>BnbCrypto.generateMnemonic(),

        generate:mnemonic=>{
            
            // generate key entropy
            let privateKey = mnemonic ? BnbCrypto.getPrivateKeyFromMnemonic(mnemonic) : BnbCrypto.generatePrivateKey(),
    
                // get an address
                address = BnbCrypto.getAddressFromPrivateKey(privateKey,'bnb'),

                publicKey = BnbCrypto.getPublicKeyFromPrivateKey(privateKey)
        

            return {privateKey,address,publicKey}    
        
        },



        sign:(data,privateKey)=>Buffer.from(BnbCrypto.generateSignature(data,privateKey)).toString('base64'),


        verify:(data,signature,pubKey)=>BnbCrypto.verifySignature(Buffer.from(signature,'base64'),data,pubKey),


        deriveFromMnemonic:mnemonic=>{
            
            let privateKey=crypto.getPrivateKeyFromMnemonic(mnemonic),

                publicKey=crypto.getPublicKeyFromPrivateKey(priv),

                address=crypto.getAddressFromPublicKey(pub,'bnb')

            return {privateKey,publicKey,address}
        
        },

    },




    EOS:{
        
        generate:()=>ecc.randomKey().then(privateKey=>({privateKey,address:ecc.privateToPublic(privateKey)})),

        sign:(data,privateKey)=>ecc.sign(data,privateKey),

        verify:(data,signature,address)=>ecc.verify(signature,data,address),

        toPUB_K1:EOSaddress=>EosJS.PublicKey.fromString(EOSaddress).toString(),

        toLegacy:PUB_K1address=>EosJS.PublicKey.fromString(PUB_K1address).toLegacyString()

    },




    HELIUM:{

        generate:async()=>{
            
            let kp=await HeliumKeypair.makeRandom()

            return {publicKey:Buffer.from(kp.publicKey).toString('base64'),privateKey:Buffer.from(kp.privateKey).toString('base64'),address:kp.address.b58}

        },

        sign:(data,privateKey)=>
        
            Buffer.from(
                
                nacl.sign.detached(new Uint8Array(Buffer.from(data)),new Uint8Array(Buffer.from(privateKey,'base64')))
                
            ).toString('base64'),




        verify:(data,signature,address)=>
        
            nacl.sign.detached.verify(
                
                new Uint8Array(Buffer.from(data)),new Uint8Array(Buffer.from(signature,'base64')), new Uint8Array( Address.fromB58(address).publicKey )
                
            ),


    },




    ARWEAVE:{

        generate:()=>arweave.wallets.generate(),

        sign:(data,JWK)=>Arweave.crypto.sign(JWK,new Uint8Array(Buffer.from(data,'utf-8'))).then(sig=>sig.toString('base64')),

        verify:(data,signature,JWK_n)=>
            
            Arweave.crypto.verify(JWK_n,  new Uint8Array(Buffer.from(data,'utf-8')),  new Uint8Array(Buffer.from(signature,'base64'))),

        getAddress:JWK=>arweave.wallets.jwkToAddress(JWK)


    },




    STELLAR:{

        generate:()=>StellarKeypair.random(),

        sign:(data,keyPair)=>keyPair.sign(Buffer.from(data,'utf-8')).toString('base64'),

        verify:(data,signature,pubKey)=>{

            let kp=StellarKeypair.fromPublicKey(pubKey)//just create pair with no knowledge about private keys but with ability to verify


            return kp.verify(Buffer.from(data,'utf8'),Buffer.from(signature,'base64'))

        },

        deriveFromPrivate:(privateKey)=>StellarKeypair.fromSecret(privateKey),

        toTransfer:(keyPair)=>(
            
            {pub:keyPair.publicKey(),prv:keyPair.secret()}
            
        )

    },




    POLKADOT:{

        generate:(mnemonic=mnemonicGenerate())=>{

            let seed=mnemonicToMiniSecret(mnemonic),

                {publicKey,secretKey} = nacl.sign.keyPair.fromSeed(seed)

            return {seed:Buffer.from(seed).toString('base64'), publicKey:Buffer.from(publicKey).toString('base64'), secretKey:Buffer.from(secretKey).toString('base64')}

        },


        sign:(data,privateKey)=>
            
            //Return signature in base64 format for easy transfer
            Buffer.from(nacl.sign.detached( new Uint8Array(data),  new Uint8Array(Buffer.from(privateKey,'base64')))).toString('base64'),



        verify:(data,signature,pubKey)=>
        
            nacl.sign.detached.verify(
                
                new Uint8Array(data),
                new Uint8Array(Buffer.from(signature,'base64')),
                new Uint8Array(Buffer.from(pubKey,'base64'))
                
            ),


        
        toKusama:pubKey=>encodeAddress(Buffer.from(pubKey,'base64'),2),

        toSubstrate:pubKey=>encodeAddress(Buffer.from(pubKey,'base64'),42),

        toPolkadot:pubKey=>encodeAddress(Buffer.from(pubKey,'base64'),0),

    },


    MINA:{

        generate:()=>MinaSDK.genKeys(),

        sign:(data,keyPair)=>MinaSDK.signMessage(data,keyPair),

        verify:signatureObj=>MinaSDK.verifyMessage(signatureObj),

        derivePublicKey:privateKey=>MinaSDK.derivePublicKey(privateKey)

    },




    HARMONY:{

        generate:()=>{
            
            let acc=new Account()

            return {publicKey:acc.publicKey,privateKey:acc.privateKey,address:acc.address}

        },


        sign:(data,privateKey)=>Harmony.sign(`0x${Buffer.from(data,'utf-8').toString('hex')}`,privateKey),


        verify:(data,signature,pubKey)=>Harmony.verifySignature(`0x${Buffer.from(data,'utf-8').toString('hex')}`,signature,pubKey),


        toHarmonyFormat:address=>Harmony.toBech32(address)



    },


    COSMOS:{

        
        generate:()=>createWalletFromMnemonic(mnemonicGenerate()),


        sign:(data,privateKey)=>{

            let toSign=new Uint8Array(Buffer.from(crypto.createHash('sha256').update(data).digest('hex'),'hex')),

                signature=secp256k1.ecdsaSign(toSign,privateKey)

            signature.signature=Buffer.from(signature.signature).toString('base64')

            return signature

        },

        verify:(data,signature,publicKey)=>

            secp256k1.ecdsaVerify(
                
                new Uint8Array(Buffer.from(signature.signature,'base64')),
            
                new Uint8Array(Buffer.from(crypto.createHash('sha256').update(data).digest('hex'),'hex')),
            
                new Uint8Array(publicKey)
                
            )

    },




    SOLANA:{

        generate:()=>{

            let {publicKey,secretKey}=SolanaWeb3.Keypair.generate()

            //export in BASE64 format
            return {
                        publicKey:Buffer.from(publicKey.toBytes()).toString('base64'),
                        
                        privateKey:Buffer.from(secretKey).toString('base64')
                    
                    }

        },

        //Signature in exportable form
        sign:(data,privateKey)=>
        
            Buffer.from(

                nacl.sign.detached(
                    
                    new Uint8Array(Buffer.from(data,'utf-8')),
                    new Uint8Array(Buffer.from(privateKey,'base64'))
                    
                )

            ).toString('base64'),




        
        verify:(data,signature,pubKey)=>
            
            nacl.sign.detached.verify(
                
                new Uint8Array(Buffer.from(data,'utf-8')),
                new Uint8Array(Buffer.from(signature,'base64')),
                new Uint8Array(Buffer.from(pubKey,'base64'))
            
            ),


        getAddress:pubKey=>
        
            new SolanaWeb3.Keypair(
                
                {publicKey:new Uint8Array(Buffer.from(pubKey,'base64'))}
            
            ).publicKey.toBase58(),

        
        

    },


    ZILLIQA:{

        // generate:()=>Zil.getAccountFrom0xPrivateKey(Zil.randomBytes(32)),

        // sign:(data,privateKey,pubKey)=>Zil.sign(Buffer.from(data,'utf-8'),privateKey,pubKey),

        // verify:(data,signature,publicKey)

    }


}